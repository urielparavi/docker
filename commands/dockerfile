# FROM - Allow us to build our image up on another base image. sidenote: we could build a Docker image from scratch,
# but we always want some kind of operating system layer in there, some kind of other tool which our code needs
FROM node:12

# WORKDIR: Working directory that tells Docker that all the comands will be executed from inside that folder, so app folder 
# (in our case)
WORKDIR /app

# Since all layers changes after the changing layer, we add the package.json here, so when we'll change our source code
# (when we copy after npm install) only the subsequent instructions we'll re-execute, and then the docker we'll not run
# npm install when the source code change, since there is no need, because our dependencies not changed
COPY package.json /app

# RUN - We telling Docker after copying, to run npm install on our image for all the dependencies 
RUN npm install

# COPY - We tell Docker which files that live here on our local machine, should go into the image, and we specify two path here

# First path: path of the outside container/image where the files leave that should be copied into the image, and a dot 
# means that is the same folder that contain the Dockerfile. So, it tell Docker that all 
# folders, sub folders, files should be copie into the image

# Second path: the path inside of the image where those files should be stored. In our case, it's the sub folder app
# where all our folders/subfolders, files where the Dockerfile, so all of them will copied to /app. And if this folder not
# exist it will be created
COPY . /app

# We expose the port from our isolated conatiner to our local machine, but actually this more instruction for 
# documentation purposes, so we don't need this for run our container
EXPOSE 80

# Anonymous Volume
# The path inside the container which should be mapped to some folder outside of the container and where data
# should survive if we'll delete the container. In this case it will not survive if the container will delete,
# because it's anonymous volume (as long as we created the container with --rm command)
VOLUME [ "/app/feedback" ]

# VOLUME [ "/app/node_modules" ]

# So our node server will run when a container is started based on the image, and not the imaged itself.
# The difference between RUN and CMD, that RUN will setting up our image, but CMD will activate it on the container based
# from our image
# CMD [ "node", "server.js" ]

CMD [ "npm", "start" ]


# COMMANDS

# docker build . => With the dot we tell Docker that the Dockerfile will be in the same folder as we're running this command

# -d : Run the container in detached mode - i.e. output printed by the container is not visible,
# the command prompt / terminal does NOT wait for the container to stop

# The -t flag allows us to assign a name to the image, which makes it easier to refer to when running

# CHECKING ERROR/S

# We looking in the output of the container to see what went wrong
# docker logs feedback-app (feedback-app -containers name)


# DELETE IMAGES & CONTAINERS - *Sidenote* We can only remove images if we remove their containers first

# docker container prune - Allow us to delete all our stoped containers
# docker rm - Allow us to delete specific or multiple containers with their names

# docker images - Allow to see all our images

# docker image prune - Allow us to remove all our images which have not tags.
# docker image prune -a - Allow us to remove all unused images including images with the tags
# docker rmi - Allow us to remove specific or multiple images with their names

# docker system prune -a => Allow us to clean up unused images, so it's clear everything from the docker system 

# --rm - Create container and remove it automatically when it stop (more details on docker run --help)
# example: docker run -p 3000:80 -d --rm 05c377af849a

# docker image inspect 05c377af849a - Give us information about the image


# ENTERING INTERACTIVE MODE 

# In this example we illustrate a case where we only want to run software/app and not run it as a web server - so, we want 
#  to be in attached state, but in listening mode and also to be able input something, so interact with our container

# - i - t / -it => With the combining of the i and the t flags we'll able to be in listening mode, and also to input something 
# when we run our container. So the container will listen for our input, and we'll also get a terminal exposed by the 
# container, which is the device where we enter the input (for more details on -i or -t flags, check docker run --help)
# docker run -it f5396224a0d1

# If we restarting the container and we want to listen mode and also to be able to input something mode, we'll use -a -i.

# So the difference between the -it/-i -t and the -a -i, is the -it for when we running our container, and -a -i when we 
# restart our container (for more details on -a or -i flags, check docker start --help)
# docker start -a -i relaxed_grothendieck


# CP COMMAND - allow us to copy files of folders into running container or out of a running container to our local host machine

# Here we copy everything in the dummy folder from our local host machine to this container to test folder (if it not 
# exist, it will created)
# docker cp dummy/. youthful_archimedes:/test

# Here we copy from the test folder in our container to the dummy folder in our local host machine 
# docker cp youthful_archimedes:/test dummy

# Here we copy from the test folder in our container only the test.txt file to the dummy folder in our local host machine 
# docker cp youthful_archimedes:/test/test.txt dummy


# NAMING & TAGGING CONTAINERS AND IMAGES

# Here we give a name for container
# docker run -p 3000:80 -d --rm --name goalsapp 74da73ce6927 (for more details check docker run --help)

# In image, the image tags(name & tag combination) consists of two parts - the actual name (repository), and the tag. 
# so, name:tag
# So with the name we set general name, and with the tag we define a more specialized version of that image 
# For example: node:12

# We build our image and give it name of goals, and tag latest, to indicate that this is latest version of the goalsapp
# The -t flag allows us to assign a name to the image, which makes it easier to refer to when running
# docker build -t goals:latest . (for more details check docker build --help) 

# We run and give the container name 'goalsapp' and plug in the image with the tag 'goals:latest' instead the image ID
# docker run -p 3000:80 -d --rm --name goalsapp goals:latest

# PUSHING IMAGES TO DOCKERHUB 

# *Sidenote* - if we push/pull to a private registry (other provider), we need to inlude the host, so the url of the provider
# for example - HOST:NAME

# We need to verify that this is our account for pushing images to dockerhub. 
# login (we can also logout after)

# For pushing image to dockerhub we need to create reopository and give our image the name that we set in dockerhub
# for example: urielpa/node-hello-world:tagname

# First way - create new image with that name
# docker build -t urielpa/node-hello-world .

# Second way - we reuse that image that we have already and renaming it for retaggin images
# *Sidenote* when we renaming an image, we create a clone of the old image, so the old image not deleted

# docker tag node-demo:latest urielpa/node-hello-world(:latest)
# node-demo:latest - old name, urielpa/node-hello-world - new name (we can also allocate it a tag)

# docker push urielpa/node-hello-world(:tagname)


# PULLING & USING SHARED IMAGES THROUGH DOCKERHUB

# *Sidenote* when we pull, we always pull the latest image of that name from your container registry.
# So if in the meantime we rebuild the image, and push an updated imaged to the registry,
# the next time we'll execute docker pull, we'll fetch that latest image,
# but if we have an image locally because we pulled or run it before, if we'll run a container again based on an image,
# docker run will not check if the image that we have locally on our system is the latest version of that image.
# So if the meantime we update the image and pushed it again to dockerhub and we using 'run docker' there after,
# we'll not get the latest updated image. So we need to manually 'run ducker pull' and then the image name first
# to ensure that we have the latest image version, and then execute 'docker run again'

# docker pull urielpa/node-hello-world   

# EXAMPLES OF CREATEING IMAGES & CONTAINERS (WITH VOLUMES)

# We create image with the name feedback-node
# docker build -t feedback-node .

# We run container on port 3000 on our local machine in detached mode with containr's name feedback-app based
# feedback-node image, and after that it will be rmoved
# docker run -p 3000:80 -d --name feedback-app --rm feedback-node

# docker run -d -p 3000:80 --rm --name feedback-app feedback-node:volumes


# VOLUMES COMMANDS

# docker volumes ls - give us the list of the volumes   


# Volumes - folders on our host machine in the hard drive, which available into the containers, so the data in our 
# machine it exactly like our data in the folder in the container that we defined. So if the data changes in one place, 
# it will change in both, and so the information will persist even if the container will deleted, because it will stay 
# on our machine

# ANONYMOUS VOLUMES VS NAMED VOLUMES

# Anonymous Volume - anonymous volume it attached to specific container. So, if the container will delete, 
# the volume will not survive, and it will erase
# example of anonymous volume: VOLUME [ "/app/feedback" ]

# Named volume - volume that can persist from container to a new container even if his previous container deleted


# CREATING ANONYMOUS VOLUMES & NAMED VOLUMES & DLEETING THEM

# *Sidenote* if we're not adding --rm when we creating our container with anonymous volume, we'll need to delete the  
# volume and also the container, but if we adding the --rm, it will erase both with the container

# Example to create image with a name and volume as a tag
# docker build -t feedback-node:volumes .

# *Sidenote* important that when we creating new container and want to connect to volume, that it will be the same name
# of the volume that we named and created

# Example to create container based imaged with named volume
# docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes

# Delete specific volume - docker volume rm feedback (feedback - volume name)/e329b312edf7c0e4ddf6bb6a1(volume id)

# Delete all volumes - docker volume prune 


# BIND MOUNTS

# Bind Mounts - It's similar to volume, but the difference that we managed the path and the folder of our app in our 
# local machine, and not Docker like with volume that we don't know where it locate. Also the code will not copied from  
# COPY . . snapshot, but instead from the bind mount, so that folder of our app that we specify for that, and his big 
# advantage it's that we can persist editable data with him - so code that we changing in live within the container will 
# save without creating new image or new container, because whenever that the code inside the folder of our app that we 
# specified will change, it will reflected from it


# We setting/creating a Bind Mount

# First way:

# "%cd%" => The absolute path to the folder in our local machine where we are, and where we have all the source code
#  in our case. and this code would go to the mapped folder, in our case this is the app folder (the working direcotry) 
# in the container

# "%cd%":/app => Our root/working direcotry in the container where we have all the source code, so the mapped folder,
# the app folder that we specified as a working directory, because we wanna control the entire app folder, so our code 
# will change and reflected on our local machine in a live way. So basically we copy our main folder to the main folder 
# (app) in the container and so if we change code on the local machine, it will also change in the container and so any 
# change made on the local machine will automatically be visible in the container as well.

# Second way:

# ${PWD} => equal to "%cd%"
# ${PWD}:/app  => equal to "%cd%":/app 

# Work only from the powershell 
# docker run -d -p 3000:80 (--rm) --name f-app -v feedback:/app/feedback -v ${PWD}:/app feedback-node:volumes
# docker run -d -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "%cd%":/app feedback-node:volumes


# COMBINING & MERGING DIFFERENT VOLUMES - Creating named volume & bind mount & anonymous volume


# -v /app/node_modules - anonymous volume because it has no name, and we can create it also like this: 
# VOLUME [ "/app/node_modules" ], but we'll need to create an new image, so we're not using this way.
# So, essentially we overwrite our bind mount where we're copied our source code from our local machine 
# to the root/working directory (app) in the container without the dependencies (because that we have no 
# dependencies in our local machine) with anonymous volume with longer internal/specific path, with the 
# source code from the container, so we overwrite it with the return first snapshot where we had the node  
# modules in the container, when we created the image

# docker run -d -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "%cd%":/app -v /app/node_modules  feedback-node:volumes


# ADJUSTMENT FOR NODEMON TO NODEJS

# We needed to add -L in the scripts for nodemon for nodemon work in windows
# For more details check in: https://github.com/remy/nodemon#application-isnt-restarting

# "scripts": {
#     "start": "nodemon -L server.js"
#   },