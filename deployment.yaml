# This is a required field that tells Kubernetes which version of the API to use when we managing the object we defining.
apiVersion: apps/v1
# Here we defined a kind key, so the kind of kubernetes object we wanna create and it could be Deployment, Service, Job etc..
kind: Deployment
metadata:
  name: second-app-deployment
  # We added label - 'group: example' for the Deployment ojbect, so this label represent the deployment object and not the pod
  # or something else
  labels:
    group: example
# spec - The specification of the deployment object
spec:  
  # replicas - The number of pod instances that we want as a default. So if we expect a lot of traffic we can set it to
  # more than one pod. So we can have multipule pods we we increase the replicas, but it's always the same pods with
  # the same containers inside of it. If we want different pods with different containers, we need different deployments
  replicas: 1
  # On the selector key we add a match lables key or matchExpressions
  # selector - With the selector we can connect other resource to our resource (in our case the deployment 
  # ojbect), for example to connect pods to this deployment object with the selector by matchLabels or match expressions.
  selector:
    # matchLabels - key value pair of the pod labels we wanna match with this deployment object. So when we add these key value
    # pair, it sees if there are any pods with these key value that it should control, and it could be even mutiple key values
    # that specified on one pod 
    matchLabels:
      app: second-app
      tier: backend
      # matchExpressions - is a more powerful way of selecting things where we simply have more configuration options,
      # where we can do more. So we have list of expressions which all have to be satisfied on order to have a matching object.
      # The operator can only accept specific values - In, NotIn, Exists, DoesNotExist (check in documantation).
      # So what saying here it's that we wanna select all pods where the 'app' label has a value in this range that we added
      # in the array, so: second-app, first-app, so one of this values, which of cource would be true for the pod
      # 'app: second-app', because it has an 'app' label with the value of 'second app' which is one of the two supported labels
      # specified here.
      # matchExpressions:
      #   - {key: app, operator: In, values: [second-app, first-app]}
  # template - Here we defined the pods that should be created as part of this deployment 
  # Sindenote - template always describes a pod, so it always will be a pod object, and therefore we don't need to 
  # add Kind: Pod
  template:
    # metadata - Since pod is a new object in the Kubernetes world, we need to defined it with metadata 
    metadata:
      # The labels of our pod - they can be one or more lables, but we need to make sure that they are same lables
      # (key and the value) that we specified on the selector on the deployment object, and that's how this deployment
      # will know which pods which are out there runing in the cluster should be controlled by it
      labels:
        app: second-app
        tier: backend
    # spec - The specification of the Pod object, so how this individual pod/s should configured    
    spec:
      containers:
        - name: second-node
          # If we want to update our container without changing the image name or changing the tag name like: 
          # kub-first-app => kub-first-app:2 or kub-first-app:2 => kub-first-app:3, we can add the latest tag
          # and this way it will always pull the image and use the latest image therefore, but if we don't specify colon
          # latest, it will not repull it.
          # image: urielpa/kub-first-app:latest
          image: urielpa/kub-first-app:2
          # imagePullPolicy - Another way to pick our update/latest image without changing the image name or the tag.
          # So with imagePullPolicy kubernetes pull the latest image without us having to changing the name or the tag,
          # since we changing the policy of picking the image
          imagePullPolicy: Always
          # We define how kubernetes should verify whether that container is up and running - so the default health check 
          # by kubernetes would work as before as well, but it's still works with our own livenessProbe.
          # So defining such a livenessProbe can be very useful if we have an application which doesn't react to the default,
          # or if we simply want to check the health by sending a request to slash something insead of just slash. 
          # So knowing how that can be defined can be very helpful to ensure that our application work no matter how they
          # are structured of configured
          # livenessProbe - We configure with that health check of our pod/container by kubernetes, so we change how this 
          # container is checked by kubernetes to see whether it's up and runing.
          livenessProbe: 
            # httpGet - we define configure the Gethttp request that should be sent by the kubernetes to runing application 
            httpGet:
              # Of course it that it could be another nested path our application might have
              path: /
              # Our port in our container, since that's the port this containar exposes
              port: 8080
            # We define how often the check health that should be performed, so 10 seconds meaning that every 10 seconds
            # we'll check if our app is healty or not
            periodSeconds: 10
            # Here we define how long it should wait until it checks the health for the first time
            initialDelaySeconds: 5  
          # If we want we can have multipule containers in our pod
          # - name: ...
            # image: ...
              
