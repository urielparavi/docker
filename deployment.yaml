apiVersion: apps/v1
kind: Deployment
metadata: 
  name: story-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: story
  template:
    metadata:
      labels:
        app: story
    spec: 
      containers:
        - name: story
          image: urielpa/kub-data-demo:2
          # We can add env key here and below that we can set up all our environment key value paris which we might need
          # simply by adding a list of environment variables by using dashes here.
          # So we make it more flexible - If we want to go for a different folder name, we only need to make changes here
          # in our containers in the deployment here, and not make changes in app.js and rebuild the imaged and also push 
          # it to Docker Hub
          env: 
            # So we chosing the name that we defined in app.js for our story folder and we provide his value.
            - name: STORY_FOLDER
              # Our previous way to use environment variables here in this file
              # value: 'story'
              # Since we used the ConfigMap, we need to add the valueFrom
              valueFrom: 
                # configMapKeyRef - Allow us to point at a specific ConfigMap and there in that map a specific data key
                # which holds the value we wanna set as a value for this environment variable in this container
                configMapKeyRef:
                  # The name of the ConfigMap
                  name: data-store-env
                  # folder - our key name in the ConfigMap
                  key: folder
          # Here we bind the volume into a container
          volumeMounts: 
              # Here we define where which volume should be mounted
              # mountPath - This is the container internal path where this should be mounted, and this depends on our 
              # application and where it's going to write data. This application is going to wrire data in a story folder,
              # and it's doing this inside of the project folder of this code file and therefore in the working directory
              # set up by the image. So app is the working directory in the dockerfile and in there we're accessing a 
              # story folder where this text.txt file is created, and that's what we also define in the docker-compose file -
              # so the named volume - stories:/app/story. So in short we tell Kubernetes, which type of volume should be created
              # here
            - mountPath: /app/story
              # We point at the volume name, since we can have multiple volumes for a different containers or also because 
              # maybe one container once use different volumes and different volumes types for different container internal path
              name: story-volume
      # Here we define all the voulume/s that should be part of this pod and all the containers in that pod will be able 
      # to use that voulme/s       
      volumes:
      # Our voulme name
        - name: story-volume
          # By the persistentVolumeClaim we connect our pod to our claim (host-pvc) so that ultimately it reaches out to the
          # persistent volume host-pv and gets its volume 
          # Sidenote - We can also use this claim in different pods, so we can use one of the same claim in different types
          # of pods
          persistentVolumeClaim:
            # We specify the claim name, because we might have multiple claims
            claimName: host-pvc

          # ***Here we used the emptyDir, hostPath - the approaches we used before we use claiming***
          # We set up the volume type/driver, here we use the emptyDir type and we set it to empty object - this means that we
          # don't have any specific configuration for it, but that we just want to use this type as it is with all its default
          # settings
          # emptyDir - Creates a new emapy directory whenever the pod starts and it keeps this directory alive and filled 
          # with data as long as the pod is alive. Containers can then write to this directory and if containers restart or
          # are removed the data survives, but if the pod should be removed, this directory is removed, and when the pod
          # is recreated, a new empty directory is created
          # emptyDir: {}    
          # hostPath - This allow us to set a path on the host machine, so on the worker node, so the machine that running this
          # pod/s and then the data from tha path will be exposed to the different pods that on the same machine/workder node. 
          # So multiple pods can share one in the same path on the host machine insead of pod-specific paths - like 'emptyDir'
          # which are only useful if it's the same pod which handle all the requests, but with hostPath we won't solve the 
          # problem that we could have multiple node machines/node workers and then the hostPath is still specific to one host
          # machine, since the hostPath is bind to one specific host machine/node worker. So if we have different pods on some 
          # other machine/node worker, they will not recognize the path/our directory, and actually it's like a bind mount just
          # that in this case our directory will be shared to all the pods that inside their machine
          # hostPath: 
            # path - The first key which we need to set is the path on the host machine where the data should be stored.
            # So not the path in the container, but the path on the host machine, and actually we share the path and whatever
            # is inside of that folder with this path in the container '/app/story'. So we could use hostPath to share some
            # already existing data, so we'll share whatever is inside of this path - this directory (/data) with the path
            # inside of the container '/app/story'
            # path: /data 
            # We provide a type to let kubernetes know how this path '/data' should be handled 
            # DirectoryOrCreate - this means this should be an existing directory or it's created if it's not existing yet.
            # We could also set this to just Directory which means the '/data' directory, but it would fail it it doesn't exist
            # yet
            # type: DirectoryOrCreate
        
       

          
