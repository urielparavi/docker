# When we merge objects, better practice to start with the service object. It will be okey on the other way, but that's the
# convention
# Service object - Exposes pods to the cluster or externally/outside world. So we don't control deployments with a service
# but instead pods, but of course pods are typically generated by a deployment
apiVersion: v1
# We need to specify the kind of object for kubernetes - Service, Deployment, Job etc. Here we need the Service resource
kind: Service
metadata: 
  # We naming the service 'backend'
  name: backend
# spec - The specification/configuration of the service  
spec: 
  # selector - Identifies which other resources should be controlled or connected to this service resource.
  # In this case we wanna define which pods should part of this service
  # Sidenote - Here we don't need 'mathLabels' since in the service it used older sintax, so the labels are enough, since 
  # we using really just labels (key value) here.
  # *Important* - If we have mutiple deployment objects with different labels and we want that our service will control on there
  # pods, we could specify one label that is identical on both of them. So if we have for example one deployment with a labels 
  # of 'app: second-app' and 'app: second-frontend' and we have another deployment with lables of 'app: second-app' and 
  # 'app: second-backend', we can specify only the label which is same in both, so the 'app: second-app', because
  # is the same on both of the deployments. And like this we use our service to controll multiple pods by sharing the 
  # unique/same label that exist on the other deployments
  selector: 
    # Our label from deployment.yaml, so the label that represent our pod in this deployment
    app: second-app
  # The ports which we decided to expose for our pods with our service, so we can expose multiple ports
  ports:
    # We using the default protocol 'TCP'
    - protocol: 'TCP'
      # The ports we wanna expose on our local machine, so the outside world port on the browser
      port: 80
      # targetPort - the port which our app listening on in the container
      targetPort: 8080
    # - protocol: 'TCP'
    # port: 443
    # targetPort: 443
  # The type could be ClusterIP, NodePort and the LoadBalancer  
  type: LoadBalancer
# --- This is a yaml specific syntax which means a brand new object starts thereafter and it must be 3 dashes  
---
# This is a required field that tells Kubernetes which version of the API to use when we managing the object we defining.
apiVersion: apps/v1
# Here we defined a kind key, so the kind of kubernetes object we wanna create and it could be Deployment, Service, Job etc..
kind: Deployment
metadata:
  name: second-app-deployment
# spec - The specification of the deployment object
spec:  
  # replicas - The number of pod instances that we want as a default. So if we expect a lot of traffic we can set it to
  # more than one pod. So we can have multipule pods we we increase the replicas, but it's always the same pods with
  # the same containers inside of it. If we want different pods with different containers, we need different deployments
  replicas: 1
  # On the selector key we add a match lables key or matchExpressions
  selector:
    # matchLabels - key value pair of the pod labels we wanna match with this deployment object. So when we add these key value
    # pair, it sees if there are any pods with these key value that it should control, and it could be even mutiple key values
    # that specified on one pod 
    matchLabels:
      app: second-app
      tier: backend
  # template - Here we defined the pods that should be created as part of this deployment 
  # Sindenote - template always describes a pod, so it always will be a pod object, and therefore we don't need to 
  # add Kind: Pod
  template:
    # metadata - Since pod is a new object in the Kubernetes world, we need to defined it with metadata 
    metadata:
      # The labels of our pod - they can be one or more lables, but we need to make sure that they are same lables
      # (key and the value) that we specified on the selector on the deployment object, and that's how this deployment
      # will know which pods which are out there runing in the cluster should be controlled by it
      labels:
        app: second-app
        tier: backend
    # spec - The specification of the Pod object, so how this individual pod/s should configured    
    spec:
      containers:
        - name: second-node
          image:  urielpa/kub-first-app:2
          # If we want we can have multipule containers in our pod
          # - name: ...
            # image: ...
              
