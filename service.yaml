# Service object - Exposes pods to the cluster or externally/outside world. So we don't control deployments with a service
# but instead pods, but of course pods are typically generated by a deployment
apiVersion: v1
# We need to specify the kind of object for kubernetes - Service, Deployment, Job etc. Here we need the Service resource
kind: Service
metadata: 
  # We naming the service 'backend'
  name: backend
  # We added label - 'group: example' for the Service ojbect, so this label represent the service object 
  labels: 
    group: example
# spec - The specification/configuration of the service  
spec: 
  # selector - Identifies which other resources should be controlled or connected to this service resource.
  # In this case we wanna define which pods should part of this service
  # Sidenote - Here we don't need 'mathLabels' since in the service it used older sintax, so the labels are enough, since 
  # we using really just labels (key value) here.
  # *Important* - If we have mutiple deployment objects with different labels and we want that our service will control on there
  # pods, we could specify one label that is identical on both of them. So if we have for example one deployment with a labels 
  # of 'app: second-app' and 'app: second-frontend' and we have another deployment with lables of 'app: second-app' and 
  # 'app: second-backend', we can specify only the label which is same in both, so the 'app: second-app', because
  # is the same on both of the deployments. And like this we use our service to controll multiple pods by sharing the 
  # unique/same label that exist on the other deployments
  selector: 
    # Our label from deployment.yaml, so the label that represent our pod in this deployment
    app: second-app
  # The ports which we decided to expose for our pods with our service, so we can expose multiple ports
  ports:
    # We using the default protocol 'TCP'
    - protocol: 'TCP'
      # The ports we wanna expose on our local machine, so the outside world port on the browser
      port: 80
      # targetPort - the port which our app listening on in the container
      targetPort: 8080
    # - protocol: 'TCP'
    # port: 443
    # targetPort: 443
  # The type could be ClusterIP, NodePort and the LoadBalancer  
  type: LoadBalancer
